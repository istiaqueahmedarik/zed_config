{
  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "Print to console": {
    "prefix": "log",
    "body": ["console.log('$1');", "$2"],
    "description": "Log output to console"
  },
  "lazy segment tree": {
    "prefix": "lazy",

    "body": [
      " struct",
      "{",
      "    int lazy;",
      "    int mn;",
      "} Tree[300001 * 4];",
      "int MX;",
      "const int n = 1e6 + 1;",
      "int arr[300001];",
      "",
      "void segment_tree(int node, int b, int e)",
      "{",
      "    if (b >= e)",
      "    {",
      "        if (b == e)",
      "        {",
      "            Tree[node].mn = arr[b];",
      "        }",
      "        return;",
      "    }",
      "    int mid = (b + e) / 2, child1 = node * 2, child2 = child1 + 1;",
      "    segment_tree(child1, b, mid);",
      "    segment_tree(child2, mid + 1, e);",
      "    Tree[node].mn = min(Tree[child1].mn, Tree[child2].mn);",
      "}",
      "",
      "void update(int node, int b, int e, int i,",
      "            int j, int val)",
      "{",
      "",
      "    if (Tree[node].lazy != 0)",
      "    {",
      "        Tree[node].mn += Tree[node].lazy;",
      "",
      "        if (b != e)",
      "        {",
      "            Tree[node * 2].lazy += Tree[node].lazy;",
      "            Tree[node * 2 + 1].lazy += Tree[node].lazy;",
      "        }",
      "",
      "        Tree[node].lazy = 0;",
      "    }",
      "",
      "    if (b > e || b > j || e < i)",
      "        return;",
      "",
      "    if (b >= i && e <= j)",
      "    {",
      "        Tree[node].mn += val;",
      "",
      "        if (b != e)",
      "        {",
      "            Tree[node * 2].lazy += val;",
      "            Tree[node * 2 + 1].lazy += val;",
      "        }",
      "        return;",
      "    }",
      "",
      "    int mid = (b + e) / 2;",
      "    update(node * 2, b, mid, i, j, val);",
      "    update(node * 2 + 1, mid + 1, e, i, j, val);",
      "",
      "    Tree[node].mn = min(Tree[node * 2].mn, Tree[node * 2 + 1].mn);",
      "}",
      "",
      "int query(int node, int b, int e, int i, int j)",
      "{",
      "",
      "    if (Tree[node].lazy != 0)",
      "    {",
      "",
      "        Tree[node].mn += Tree[node].lazy;",
      "",
      "        if (b != e)",
      "        {",
      "            Tree[node * 2].lazy += Tree[node].lazy;",
      "            Tree[node * 2 + 1].lazy += Tree[node].lazy;",
      "        }",
      "",
      "        Tree[node].lazy = 0;",
      "    }",
      "",
      "    if (b > e || b > j || e < i)",
      "        return INT_MAX;",
      "",
      "    if (b >= i && e <= j)",
      "        return Tree[node].mn;",
      "",
      "    int mid = (b + e) / 2;",
      "    return min(query(2 * node, b, mid, i, j),",
      "               query(2 * node + 1, mid + 1, e, i, j));",
      "}",
      "/*",
      "    segment_tree(1,1, n); //1 based array",
      "    query(1,1,n,a,b)); //1 based array and [l..r], l and r is 1 based",
      "            update(1,1,n,l,r,val);",
      "",
      "*/"
    ],
    "description": "Lazy Segment Tree"
  },
  "Segment Tree": {
    "prefix": "SegmentTree",
    "body": [
      "",
      "int seg[(int)8e5 + 5];",
      "int arr[(int)2e5 + 5];",
      "",
      "void construct_segment_tree(int root_index, int b, int e)",
      "{",
      "    if (b == e)",
      "    {",
      "        seg[root_index] = arr[b];",
      "        return;",
      "    }",
      "    int left = root_index * 2;",
      "    int right = (root_index * 2) + 1;",
      "    int mid = (b + e) >> 1;",
      "",
      "    construct_segment_tree(left, b, mid);",
      "    construct_segment_tree(right, mid + 1, e);",
      "",
      "    seg[root_index] = min(seg[left], seg[right]);",
      "}",
      "",
      "int query_sum(int root_index, int b, int e, int i, int j)",
      "{",
      "    if (i > e || j < b)",
      "    {",
      "        return INT_MAX;",
      "    }",
      "    if (i <= b && e <= j)",
      "    {",
      "        return seg[root_index];",
      "    }",
      "    int left = 2 * root_index;",
      "    int right = (2 * root_index + 1);",
      "    int mid = (b + e) / 2;",
      "    int l1 = query_sum(left, b, mid, i, j);",
      "    int r1 = query_sum(right, mid + 1, e, i, j);",
      "    return min(l1, r1);",
      "}",
      "",
      "void update(int root_index, int b, int e, int i, int nwval)",
      "{",
      "    if (i > e || i < b)",
      "    {",
      "        return;",
      "    }",
      "    if (i == b && i == e)",
      "    {",
      "        seg[root_index] = nwval;",
      "        return;",
      "    }",
      "    int left = (2 * root_index);",
      "    int right = (2 * root_index) + 1;",
      "    int mid = (b + e) >> 1;",
      "    update(left, b, mid, i, nwval);",
      "    update(right, mid + 1, e, i, nwval);",
      "    seg[root_index] = min(seg[left], seg[right]);",
      "}",
      "// construct_segment_tree(1,1,n); 1 based index",
      "// query_sum(1,1,n,l,r)  [l,r] 1 based index",
      "// update(1,1,n,i,val) 1 based index"
    ],
    "description": "Segment Tree"
  },

  "stringHashing": {
    "prefix": "hashing",
    "body": [
      "class HashedString",
      "{",
      "private:",
      "    // change M and B if you want",
      "    static const long long M = 1e9 + 9;",
      "    static const long long B;",
      "",
      "    // pow[i] contains B^i % M",
      "    static vector<long long> pow;",
      "",
      "    // p_hash[i] is the hash of the first i characters of the given string",
      "    vector<long long> p_hash;",
      "",
      "public:",
      "    HashedString(const string &s) : p_hash(s.size() + 1)",
      "    {",
      "        while (pow.size() < s.size())",
      "        {",
      "            pow.push_back((pow.back() * B) % M);",
      "        }",
      "",
      "        p_hash[0] = 0;",
      "        for (int i = 0; i < s.size(); i++)",
      "        {",
      "            p_hash[i + 1] = ((p_hash[i] * B) % M + s[i]) % M;",
      "        }",
      "    }",
      "",
      "    long long get_hash(int start, int end)",
      "    {",
      "        long long raw_val =",
      "            (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));",
      "        return (raw_val % M + M) % M;",
      "    }",
      "};",
      "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
      "vector<long long> HashedString::pow = {1};",
      "const long long HashedString::B =",
      "    uniform_int_distribution<long long>(0, M - 1)(rng);"
    ],
    "description": "stringHashing"
  },
  "hasAlternateChar": {
    "prefix": "hasAlternateChar",
    "body": [
      "class hasAlternateChar",
      "{",
      "public:",
      "    string s;",
      "    vector<vector<int>> v;",
      "    vector<vector<int>> prefix;",
      "    hasAlternateChar(string s)",
      "    {",
      "        this->s = s;",
      "        v.resize(27, vector<int>(s.size() + 1, 0));",
      "        prefix.resize(27, vector<int>(s.size() + 1, 0));",
      "        for (int i = 0; i < s.size(); i++)",
      "        {",
      "            int c = s[i] - 'a';",
      "            v[c][i] = 1;",
      "        }",
      "        prefix = v;",
      "        for (int i = 0; i < 26; i++)",
      "        {",
      "            for (int j = 0; j < s.size(); j++)",
      "            {",
      "                if (j - 2 < 0)",
      "                    continue;",
      "                prefix[i][j] += prefix[i][j - 2];",
      "            }",
      "        }",
      "    }",
      "    int query(int l, int r, char c)",
      "    {",
      "        if ((l & 1) != (r & 1))",
      "            r--;",
      "        int x = c - 'a';",
      "        if (l - 2 < 0)",
      "            return prefix[x][r];",
      "        return prefix[x][r] - prefix[x][l - 2];",
      "    }",
      "};"
    ],
    "description": "hasAlternateChar"
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "template <typename T>",
      "class Dijkstra",
      "{",
      "public:",
      "    vector<T> dist, parent;",
      "    vector<bool> vis;",
      "    T n;",
      "    vector<vector<pair<T, T>>> adj;",
      "    Dijkstra(int n)",
      "    {",
      "        this->n = n;",
      "        dist.assign(n, numeric_limits<T>::max());",
      "        parent.assign(n, -1);",
      "        vis.assign(n, 0);",
      "        adj.resize(n);",
      "    }",
      "    void addEdge(T u, T v, T w)",
      "    {",
      "        adj[u].push_back({v, w});",
      "        adj[v].push_back({u, w});",
      "    }",
      "    void dijkstra(T src)",
      "    {",
      "        dist[src] = 0;",
      "        priority_queue<pair<T, T>, vector<pair<T, T>>, greater<pair<T, T>>> pq;",
      "        pq.push({0, src});",
      "        while (!pq.empty())",
      "        {",
      "            T u = pq.top().second;",
      "            pq.pop();",
      "            if (vis[u])",
      "                continue;",
      "            vis[u] = 1;",
      "            for (auto &child : adj[u])",
      "            {",
      "                T v = child.first;",
      "                T w = child.second;",
      "                if (dist[u] + w < dist[v])",
      "                {",
      "                    dist[v] = dist[u] + w;",
      "                    parent[v] = u;",
      "                    pq.push({dist[v], v});",
      "                }",
      "            }",
      "        }",
      "    }",
      "    vector<T> getPath(T src, T dest)",
      "    {",
      "        if (dist[dest] == numeric_limits<T>::max())",
      "            return vector<T>(0);",
      "        vector<T> path;",
      "        for (T v = dest; v != -1; v = parent[v])",
      "            path.push_back(v);",
      "        reverse(path.begin(), path.end());",
      "        return path;",
      "    }",
      "};"
    ],
    "description": "dijkstra"
  },
  "euler": {
    "prefix": "euler",
    "body": [
      "vector<ll> phi(1e6 + 1), phiSum(1e6 + 1);",
      "void eulerTotient()",
      "{",
      "    for (ll i = 1; i <= 1e6; i++)",
      "        phi[i] = i;",
      "    for (ll i = 2; i <= 1e6; i++)",
      "    {",
      "        if (phi[i] == i)",
      "        {",
      "            for (ll j = i; j <= 1e6; j += i)",
      "                phi[j] -= phi[j] / i;",
      "        }",
      "    }",
      "}"
    ],
    "description": "euler"
  },

  "Main": {
    "prefix": "Main",
    "body": [
      "/*******************************************",
      " @b |I|s|t|i|a|q|u|e| |A|h|m|e|d| |A|r|i|k|",
      "********************************************/",
      "#pragma GCC optimize(\"O3\")",
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "#define static_assert(...) ;",
      "#include <tr2/dynamic_bitset>",
      "using u_bitset = tr2::dynamic_bitset<__uint128_t>;",
      "using l_bitset = tr2::dynamic_bitset<__int128_t>;",
      "void __print(int x) { cerr << x; }",
      "#define bigll __int128_t",
      "#define bigull __uint128_t",
      "#define ll int_fast64_t",
      "#define ull uint_fast64_t",
      "#define ld long double",
      "#define pi acos(-1)",
      "#define set_bits __builtin_popcountll",
      "#define all(x) (x).begin(), (x).end()",
      "#define rall(x) (x).rbegin(), (x).rend()",
      "#define IOS                  \\",
      "    ios::sync_with_stdio(0); \\",
      "    cin.tie(0);              \\",
      "    cout.tie(0);",
      "#define FileIO                        \\",
      "    freopen(\"input.txt\", \"r\", stdin); \\",
      "    freopen(\"output.txt\", \"w\", stdout)",
      "///@b decltype and const",
      "const int MOD = 1e9 + 7, dx[] = {1, 0, -1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, 1, -1, -1};",
      "///@b debug",
      "struct _",
      "{",
      "    ios_base::Init i;",
      "    _()",
      "    {",
      "        cin.sync_with_stdio(0);",
      "        cin.tie(0);",
      "        cout << fixed << setprecision(10);",
      "    }",
      "} ___;",
      "void __print(long x) { cerr << x; }",
      "void __print(long long x) { cerr << x; }",
      "void __print(unsigned x) { cerr << x; }",
      "void __print(unsigned long x) { cerr << x; }",
      "void __print(unsigned long long x) { cerr << x; }",
      "void __print(float x) { cerr << x; }",
      "void __print(double x) { cerr << x; }",
      "void __print(long double x) { cerr << x; }",
      "void __print(char x) { cerr << '\\'' << x << '\\''; }",
      "void __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }",
      "void __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }",
      "void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
      "",
      "template <typename T, typename V>",
      "void __print(const pair<T, V> &x)",
      "{",
      "    cerr << '{';",
      "    __print(x.first);",
      "    cerr << ',';",
      "    __print(x.second);",
      "    cerr << '}';",
      "}",
      "template <typename T>",
      "void __print(const T &x)",
      "{",
      "    int f = 0;",
      "    cerr << '{';",
      "    for (auto &i : x)",
      "        cerr << (f++ ? \",\" : \"\"), __print(i);",
      "    cerr << \"}\";",
      "}",
      "void _print() { cerr << \"]\\n\"; }",
      "template <typename T, typename... V>",
      "void _print(T t, V... v)",
      "{",
      "    __print(t);",
      "    if (sizeof...(v))",
      "        cerr << \", \";",
      "    _print(v...);",
      "}",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x...)               \\",
      "    cerr << \"[\" << #x << \"] = [\"; \\",
      "    _print(x)",
      "#else",
      "#define debug(x...)",
      "#endif",
      "",
      "template <typename p, typename q>",
      "using ht = gp_hash_table<p, q>;",
      "",
      "///@b PBDS",
      "// template <typename T>",
      "// using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "// template <typename T>",
      "// using o_set_g = tree<T, null_type, greater<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "// template <typename T>",
      "// using o_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "// template <typename T>",
      "// using o_multiset_g = tree<T, null_type, greater_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "",
      "inline void solve()",
      "{",
      "}",
      "",
      "auto main() -> int32_t",
      "{",
      "    IOS;",
      "    int t = 1, cs = 1;",
      "    // cin >> t;",
      "    while (t--)",
      "    {",
      "        solve();",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": "Main"
  },
  "hashing": {
    "prefix": "hashing",
    "body": [
      "const int N = 1e6 + 9;",
      "",
      "int power(long long n, long long k, const int mod)",
      "{",
      "    int ans = 1 % mod;",
      "    n %= mod;",
      "    if (n < 0)",
      "        n += mod;",
      "    while (k)",
      "    {",
      "        if (k & 1)",
      "            ans = (long long)ans * n % mod;",
      "        n = (long long)n * n % mod;",
      "        k >>= 1;",
      "    }",
      "    return ans;",
      "}",
      "",
      "const int MOD1 = 127657753, MOD2 = 987654319;",
      "const int p1 = 137, p2 = 277;",
      "int ip1, ip2;",
      "pair<int, int> pw[N], ipw[N];",
      "void prec()",
      "{",
      "    pw[0] = {1, 1};",
      "    for (int i = 1; i < N; i++)",
      "    {",
      "        pw[i].first = 1LL * pw[i - 1].first * p1 % MOD1;",
      "        pw[i].second = 1LL * pw[i - 1].second * p2 % MOD2;",
      "    }",
      "    ip1 = power(p1, MOD1 - 2, MOD1);",
      "    ip2 = power(p2, MOD2 - 2, MOD2);",
      "    ipw[0] = {1, 1};",
      "    for (int i = 1; i < N; i++)",
      "    {",
      "        ipw[i].first = 1LL * ipw[i - 1].first * ip1 % MOD1;",
      "        ipw[i].second = 1LL * ipw[i - 1].second * ip2 % MOD2;",
      "    }",
      "}",
      "struct Hashing",
      "{",
      "    int n;",
      "    string s;                  // 0 - indexed",
      "    vector<pair<int, int>> hs; // 1 - indexed",
      "    Hashing() {}",
      "    Hashing(string _s)",
      "    {",
      "        n = _s.size();",
      "        s = _s;",
      "        hs.emplace_back(0, 0);",
      "        for (int i = 0; i < n; i++)",
      "        {",
      "            pair<int, int> p;",
      "            p.first = (hs[i].first + 1LL * pw[i].first * s[i] % MOD1) % MOD1;",
      "            p.second = (hs[i].second + 1LL * pw[i].second * s[i] % MOD2) % MOD2;",
      "            hs.push_back(p);",
      "        }",
      "    }",
      "    pair<int, int> get_hash(int l, int r)",
      "    { // 1 - indexed [l, r]",
      "        assert(1 <= l && l <= r && r <= n);",
      "        pair<int, int> ans;",
      "        ans.first = (hs[r].first - hs[l - 1].first + MOD1) * 1LL * ipw[l - 1].first % MOD1;",
      "        ans.second = (hs[r].second - hs[l - 1].second + MOD2) * 1LL * ipw[l - 1].second % MOD2;",
      "        return ans;",
      "    }",
      "    pair<int, int> get_hash()",
      "    {",
      "        return get_hash(1, n);",
      "    }",
      "};"
    ],
    "description": "hashing"
  },
  "hashing2": {
    "prefix": "hashing2",
    "body": [
      "const int N = 1500 + 9;",
      "const int p1 = 137, mod1 = 127657753, p2 = 277, mod2 = 987654319;",
      "",
      "int power(long long n, long long k, int mod)",
      "{",
      "    int ans = 1 % mod;",
      "    n %= mod;",
      "    if (n < 0)",
      "        n += mod;",
      "    while (k)",
      "    {",
      "        if (k & 1)",
      "            ans = (long long)ans * n % mod;",
      "        n = (long long)n * n % mod;",
      "        k >>= 1;",
      "    }",
      "    return ans;",
      "}",
      "",
      "int ip1, ip2;",
      "pair<int, int> pw[N], ipw[N];",
      "void prec()",
      "{ // O(n)",
      "    pw[0] = {1, 1};",
      "    for (int i = 1; i < N; i++)",
      "    {",
      "        pw[i].first = 1LL * pw[i - 1].first * p1 % mod1;",
      "        pw[i].second = 1LL * pw[i - 1].second * p2 % mod2;",
      "    }",
      "    ip1 = power(p1, mod1 - 2, mod1);",
      "    ip2 = power(p2, mod2 - 2, mod2);",
      "    ipw[0] = {1, 1};",
      "    for (int i = 1; i < N; i++)",
      "    {",
      "        ipw[i].first = 1LL * ipw[i - 1].first * ip1 % mod1;",
      "        ipw[i].second = 1LL * ipw[i - 1].second * ip2 % mod2;",
      "    }",
      "}",
      "",
      "pair<int, int> string_hash(string s)",
      "{ // O(n)",
      "    int n = s.size();",
      "    pair<int, int> hs({0, 0});",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        hs.first += 1LL * s[i] * pw[i].first % mod1;",
      "        hs.first %= mod1;",
      "        hs.second += 1LL * s[i] * pw[i].second % mod2;",
      "        hs.second %= mod2;",
      "    }",
      "    return hs;",
      "}",
      "pair<int, int> pref[N];",
      "void build(string s)",
      "{ // O(n)",
      "    int n = s.size();",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        pref[i].first = 1LL * s[i] * pw[i].first % mod1;",
      "        if (i)",
      "            pref[i].first = (pref[i].first + pref[i - 1].first) % mod1;",
      "        pref[i].second = 1LL * s[i] * pw[i].second % mod2;",
      "        if (i)",
      "            pref[i].second = (pref[i].second + pref[i - 1].second) % mod2;",
      "    }",
      "}",
      "pair<int, int> get_hash(int i, int j)",
      "{ // O(1)",
      "    assert(i <= j);",
      "    pair<int, int> hs({0, 0});",
      "    hs.first = pref[j].first;",
      "    if (i)",
      "        hs.first = (hs.first - pref[i - 1].first + mod1) % mod1;",
      "    hs.first = 1LL * hs.first * ipw[i].first % mod1;",
      "    hs.second = pref[j].second;",
      "    if (i)",
      "        hs.second = (hs.second - pref[i - 1].second + mod2) % mod2;",
      "    hs.second = 1LL * hs.second * ipw[i].second % mod2;",
      "    return hs;",
      "}",
      ""
    ],
    "description": "hashing2"
  },
  "fast_sieve": {
    "prefix": "Fast_sieve",
    "body": [
      "vector<int> sieve(const int N, const int Q = 17, const int L = 1 << 15)",
      "{",
      "    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};",
      "    struct P",
      "    {",
      "        P(int p) : p(p) {}",
      "        int p;",
      "        int pos[8];",
      "    };",
      "    auto approx_prime_count = [](const int N) -> int",
      "    {",
      "        return N > 60184 ? N / (log(N) - 1.1)",
      "                         : max(1., N / (log(N) - 1.11)) + 1;",
      "    };",
      "",
      "    const int v = sqrt(N), vv = sqrt(v);",
      "    vector<bool> isp(v + 1, true);",
      "    for (int i = 2; i <= vv; ++i)",
      "        if (isp[i])",
      "        {",
      "            for (int j = i * i; j <= v; j += i)",
      "                isp[j] = false;",
      "        }",
      "",
      "    const int rsize = approx_prime_count(N + 30);",
      "    vector<int> primes = {2, 3, 5};",
      "    int psize = 3;",
      "    primes.resize(rsize);",
      "",
      "    vector<P> sprimes;",
      "    size_t pbeg = 0;",
      "    int prod = 1;",
      "    for (int p = 7; p <= v; ++p)",
      "    {",
      "        if (!isp[p])",
      "            continue;",
      "        if (p <= Q)",
      "            prod *= p, ++pbeg, primes[psize++] = p;",
      "        auto pp = P(p);",
      "        for (int t = 0; t < 8; ++t)",
      "        {",
      "            int j = (p <= Q) ? p : p * p;",
      "            while (j % 30 != rs[t])",
      "                j += p << 1;",
      "            pp.pos[t] = j / 30;",
      "        }",
      "        sprimes.push_back(pp);",
      "    }",
      "",
      "    vector<unsigned char> pre(prod, 0xFF);",
      "    for (size_t pi = 0; pi < pbeg; ++pi)",
      "    {",
      "        auto pp = sprimes[pi];",
      "        const int p = pp.p;",
      "        for (int t = 0; t < 8; ++t)",
      "        {",
      "            const unsigned char m = ~(1 << t);",
      "            for (int i = pp.pos[t]; i < prod; i += p)",
      "                pre[i] &= m;",
      "        }",
      "    }",
      "",
      "    const int block_size = (L + prod - 1) / prod * prod;",
      "    vector<unsigned char> block(block_size);",
      "    unsigned char *pblock = block.data();",
      "    const int M = (N + 29) / 30;",
      "",
      "    for (int beg = 0; beg < M; beg += block_size, pblock -= block_size)",
      "    {",
      "        int end = min(M, beg + block_size);",
      "        for (int i = beg; i < end; i += prod)",
      "        {",
      "            copy(pre.begin(), pre.end(), pblock + i);",
      "        }",
      "        if (beg == 0)",
      "            pblock[0] &= 0xFE;",
      "        for (size_t pi = pbeg; pi < sprimes.size(); ++pi)",
      "        {",
      "            auto &pp = sprimes[pi];",
      "            const int p = pp.p;",
      "            for (int t = 0; t < 8; ++t)",
      "            {",
      "                int i = pp.pos[t];",
      "                const unsigned char m = ~(1 << t);",
      "                for (; i < end; i += p)",
      "                    pblock[i] &= m;",
      "                pp.pos[t] = i;",
      "            }",
      "        }",
      "        for (int i = beg; i < end; ++i)",
      "        {",
      "            for (int m = pblock[i]; m > 0; m &= m - 1)",
      "            {",
      "                primes[psize++] = i * 30 + rs[__builtin_ctz(m)];",
      "            }",
      "        }",
      "    }",
      "    assert(psize <= rsize);",
      "    while (psize > 0 && primes[psize - 1] > N)",
      "        --psize;",
      "    primes.resize(psize);",
      "    return primes;",
      "}",
      "auto primes = sieve(n);"
    ],
    "description": "fast_sieve"
  },
  "CH2D": {
    "prefix": "CH2D",
    "body": [
      "template <typename P_, typename Q_>",
      "class CH2D",
      "{",
      "public:",
      "    vector<pair<P_, Q_>> points;",
      "    vector<pair<P_, Q_>> hull;",
      "    auto area(pair<P_, Q_> O, pair<P_, Q_> P, pair<P_, Q_> Q) -> P_",
      "    {",
      "        return (P.first - O.first) * (Q.second - O.second) -",
      "               (P.second - O.second) * (Q.first - O.first);",
      "    }",
      "    void add_point(P_ x, Q_ y)",
      "    {",
      "        points.push_back({x, y});",
      "    }",
      "    CH2D(vector<pair<P_, Q_>> points) : points(points) {}",
      "    void monotone_chain()",
      "    {",
      "        sort(points.begin(), points.end());",
      "        points.erase(unique(points.begin(), points.end()), points.end());",
      "        P_ n = points.size();",
      "",
      "        if (n < 3)",
      "        {",
      "            hull = points;",
      "            return;",
      "        }",
      "",
      "        for (auto i = 0; i < n; i++)",
      "        {",
      "            while (hull.size() > 1 &&",
      "                   area(hull[hull.size() - 2], hull.back(), points[i]) < 0)",
      "",
      "                hull.pop_back();",
      "            hull.push_back(points[i]);",
      "        }",
      "",
      "        auto lower_hull_length = hull.size();",
      "        for (auto i = n - 2; i >= 0; i--)",
      "        {",
      "            while (hull.size() > lower_hull_length &&",
      "                   area(hull[hull.size() - 2], hull.back(), points[i]) < 0)",
      "                hull.pop_back();",
      "            hull.push_back(points[i]);",
      "        }",
      "        hull.pop_back();",
      "    }",
      "    vector<pair<P_, Q_>> get_hull()",
      "    {",
      "        return hull;",
      "    }",
      "};"
    ],
    "description": "CH2D"
  },
  "astar": {
    "prefix": "astar",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "class Node",
      "{",
      "public:",
      "    int x, y;",
      "    double g, h;",
      "    Node *parent;",
      "    Node(int x, int y, double g = 0.0, double h = 0.0, Node *parent = nullptr)",
      "        : x(x), y(y), g(g), h(h), parent(parent) {}",
      "    double f() const",
      "    {",
      "        return g + h;",
      "    }",
      "",
      "    bool operator==(const Node &other) const",
      "    {",
      "        return x == other.x && y == other.y;",
      "    }",
      "};",
      "",
      "struct CompareNode",
      "{",
      "    bool operator()(const Node *a, const Node *b) const",
      "    {",
      "        return a->f() > b->f();",
      "    }",
      "};",
      "",
      "class AStar",
      "{",
      "public:",
      "    AStar(int width, int height, const set<pair<int, int>> &blockedCells)",
      "        : width(width), height(height), blockedCells(blockedCells) {}",
      "",
      "    vector<Node> findPath(const Node &start, const Node &goal)",
      "    {",
      "        priority_queue<Node *, vector<Node *>, CompareNode> openSet;",
      "        unordered_map<int, Node *> allNodes;",
      "",
      "        Node *startNode = new Node(start.x, start.y);",
      "        Node *goalNode = new Node(goal.x, goal.y);",
      "",
      "        openSet.push(startNode);",
      "        allNodes[getIndex(startNode->x, startNode->y)] = startNode;",
      "",
      "        while (!openSet.empty())",
      "        {",
      "            Node *current = openSet.top();",
      "            openSet.pop();",
      "",
      "            if (*current == *goalNode)",
      "                return reconstructPath(current);",
      "",
      "            for (const auto &neighbor : getNeighbors(current))",
      "            {",
      "                double tentative_g = current->g + distance(current, neighbor);",
      "",
      "                if (allNodes.find(getIndex(neighbor->x, neighbor->y)) == allNodes.end() || tentative_g < neighbor->g)",
      "                {",
      "                    neighbor->g = tentative_g;",
      "                    neighbor->h = heuristic(neighbor, goalNode);",
      "                    neighbor->parent = current;",
      "",
      "                    if (allNodes.find(getIndex(neighbor->x, neighbor->y)) == allNodes.end())",
      "                        openSet.push(neighbor), allNodes[getIndex(neighbor->x, neighbor->y)] = neighbor;",
      "                }",
      "            }",
      "        }",
      "        return vector<Node>();",
      "    }",
      "",
      "private:",
      "    int width, height;",
      "    set<pair<int, int>> blockedCells;",
      "",
      "    int getIndex(int x, int y) const",
      "    {",
      "        return y * width + x;",
      "    }",
      "",
      "    double heuristic(const Node *a, const Node *b) const",
      "    {",
      "        return abs(a->x - b->x) + abs(a->y - b->y);",
      "    }",
      "",
      "    double distance(const Node *a, const Node *b) const",
      "    {",
      "        return sqrt((a->x - b->x) * (a->x - b->x) + (a->y - b->y) * (a->y - b->y));",
      "    }",
      "",
      "    vector<Node *> getNeighbors(Node *node) const",
      "    {",
      "        vector<Node *> neighbors;",
      "        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};",
      "",
      "        for (const auto &dir : directions)",
      "        {",
      "            int newX = node->x + dir.first;",
      "            int newY = node->y + dir.second;",
      "",
      "            if (newX >= 0 && newX < width && newY >= 0 && newY < height && blockedCells.find({newX, newY}) == blockedCells.end())",
      "            {",
      "                neighbors.push_back(new Node(newX, newY));",
      "            }",
      "        }",
      "",
      "        return neighbors;",
      "    }",
      "",
      "    vector<Node> reconstructPath(Node *node) const",
      "    {",
      "        vector<Node> path;",
      "        while (node != nullptr)",
      "        {",
      "            path.push_back(*node);",
      "            node = node->parent;",
      "        }",
      "        reverse(path.begin(), path.end());",
      "        return path;",
      "    }",
      "};",
      "// time complexity of a* is O(b^d) where b is the branching factor and d is the depth of the solution, here branching factor is 4 and depth is 2 so time complexity is O(4^2) = O(16)",
      "",
      "int main()",
      "{",
      "    set<pair<int, int>> blockedCells = {{1, 1}, {1, 2}, {1, 3}, {9, 8}};",
      "    AStar astar(10, 10, blockedCells);",
      "    Node start(8, 8);",
      "    Node goal(9, 9);",
      "",
      "    vector<Node> path = astar.findPath(start, goal);",
      "",
      "    for (const auto &node : path)",
      "    {",
      "        cout << \"(\" << node.x << \", \" << node.y << \")\\n\";",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": "astar"
  },
  "nsum": {
    "prefix": "nsum",
    "body": [
      " int l = 1;",
      "    while (l <= n)",
      "    {",
      "        ll q = n / l;",
      "        ll r = n / q;",
      "        s.insert(q);",
      "        s.insert(r);",
      "        l = r + 1;",
      "    }"
    ],
    "description": "nsum"
  },

  "digitDP": {
    "prefix": "digitDP",
    "body": [
      "int dp[1000][4000][2];",
      "/// DP[p][c][f] = Number of valid numbers <= b from this state",
      "/// p = current position from left side (zero based)",
      "/// c = number of times we have placed the digit d so far",
      "/// f = the number we are building has already become smaller than b? [0 = no, 1 = yes]",
      "",
      "vector<int> num;",
      "",
      "int ff(int cur, int cnt, int f)",
      "{",
      "    if (cur == num.size())",
      "    {",
      "        return cnt;",
      "    }",
      "",
      "    if (dp[cur][cnt][f] != -1)",
      "        return dp[cur][cnt][f];",
      "",
      "    int ret = 0;",
      "",
      "    int mx = 9;",
      "",
      "    if (f == 0)",
      "    {",
      "        mx = num[cur];",
      "    }",
      "",
      "    for (int i = 0; i <= mx; i++)",
      "    {",
      "        int cp = f;",
      "        if (f == 0 and i < mx)",
      "            cp = 1;",
      "        int cpn = cnt;",
      "        if (i == 1)",
      "            cpn++;",
      "        ret += ff(cur + 1, cpn, cp);",
      "    }",
      "    return dp[cur][cnt][f] = ret;",
      "}",
      "",
      "int solve(int n)",
      "{",
      "    while (n)",
      "    {",
      "        num.push_back(n % 10);",
      "        n /= 10;",
      "    }",
      "    reverse(all(num));",
      "    memset(dp, -1, sizeof dp);",
      "    cout << ff(0, 0, 0) << \"\\n\";",
      "}"
    ],
    "description": "digitDP"
  }
}
